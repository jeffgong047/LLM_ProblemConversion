codes: Example for binary tree. Red nodes represent a prefix tree. The method for calculating the number of descendant leaf nodes in the full tree is shown. First, let us show that the Kraft inequality holds whenever the code for S is a prefix code. Suppose that ℓ1⩽ℓ2⩽⋯⩽ℓnℓ_1⩽ℓ_2⩽⋯⩽ℓ_n. Let A be the full r-ary tree of depth ℓnℓ_n (thus, every node of A at level <ℓn<ℓ_n has r children, while the nodes at level ℓnℓ_n are leaves). Every word of length ℓ⩽ℓnℓ⩽ℓ_n over an r-ary alphabet corresponds to a node in this tree at depth ℓℓ. The ith word in the prefix code corresponds to a node vi_i; let Ai_i be the set of all leaf nodes (i.e. of nodes at depth ℓnℓ_n) in the subtree of A rooted at vi_i. That subtree being of height ℓn−ℓiℓ_n-ℓ_i, we have |Ai|=rℓn−ℓi.|A_i|=r^ℓ_n-ℓ_i. Since the code is a prefix code, those subtrees cannot share any leaves, which means that Ai∩Aj=∅,i≠j._i_j=∅,. Thus, given that the total number of nodes at depth ℓnℓ_n is rℓn^ℓ_n, we have |⋃i=1nAi|=∑i=1n|Ai|=∑i=1nrℓn−ℓi⩽rℓn|⋃_i=1^nA_i|=∑_i=1^n|A_i|=∑_i=1^nr^ℓ_n-ℓ_i^ℓ_n from which the result follows. Conversely, given any ordered sequence of n natural numbers, ℓ1⩽ℓ2⩽⋯⩽ℓnℓ_1⩽ℓ_2⩽⋯⩽ℓ_n satisfying the Kraft inequality, one can construct a prefix code with codeword lengths equal to each ℓiℓ_i by choosing a word of length ℓiℓ_i arbitrarily, then ruling out all words of greater length that have it as a prefix. There again, we shall interpret this in terms of leaf nodes of an r-ary tree of depth ℓnℓ_n. First choose any node from the full tree at depth ℓ1ℓ_1; it corresponds to the first word of our new code. Since we are building a prefix code, all the descendants of this node (i.e., all words that have this first word as a prefix) become unsuitable for inclusion in the code. We consider the descendants at depth ℓnℓ_n (i.e., the leaf nodes among the descendants); there are rℓn−ℓ1^ℓ_n-ℓ_1 such descendant nodes that are removed from consideration. The next iteration picks a (surviving) node at depth ℓ2ℓ_2 and removes rℓn−ℓ2^ℓ_n-ℓ_2 further leaf nodes, and so on. After n iterations, we have removed a total of ∑i=1nrℓn−ℓi∑_i=1^nr^ℓ_n-ℓ_i nodes. The question is whether we need to remove more leaf nodes than we actually have available — rℓn^ℓ_n in all — in the process of building the code. Since the Kraft inequality holds, we have indeed ∑i=1nrℓn−ℓi⩽rℓn∑_i=1^nr^ℓ_n-ℓ_i^ℓ_n and thus a prefix code can be built. Note that as the choice of nodes at each step is largely arbitrary, many different suitable prefix codes can be built, in general. Proof of the general