Proof: This proof is based on the one given by Garey and Johnson.[6] There are two parts to proving that the Boolean satisfiability problem (SAT) is NP-complete. One is to show that SAT is an NP problem. The other is to show that every NP problem can be reduced to an instance of a SAT problem by a polynomial-time many-one reduction. SAT is in NP because any assignment of Boolean values to Boolean variables that is claimed to satisfy the given expression can be verified in polynomial time by a deterministic Turing machine. (The statements verifiable in polynomial time by a deterministic Turing machine and solvable in polynomial time by a non-deterministic Turing machine are equivalent, and the proof can be found in many textbooks, for example Sipser's Introduction to the Theory of Computation, section 7.3., as well as in the Wikipedia article on NP). Commutative diagram showing Cook's reduction of M to SAT. Data sizes and program runtimes are colored in orange and green, respectively. Schematized accepting computation by the machine M. Now suppose that a given problem in NP can be solved by the nondeterministic Turing machine M=(Q,Σ,s,F,δ)=(Q,Σ,s,F,δ), where Q is the set of states, ΣΣ is the alphabet of tape symbols, s∈Q is the initial state, F⊆Q is the set of accepting states, and δ⊆((Q∖F)×Σ)×(Q×Σ×−1,+1)δ⊆((Q)×Σ)×(Q×Σ×{-1,+1}) is the transition relation. Suppose further that M accepts or rejects an instance of the problem after at most p(n)(n) computation steps, where n is the size of the instance and p is a polynomial function. For each input, I, specify a Boolean expression B that is satisfiable if and only if the machine M accepts I. The Boolean expression uses the variables set out in the following table. Here, q∈Q is a machine state, −p(n)≤i≤p(n)-p(n)(n) is a tape position, j∈Σ∈Σ is a tape symbol, and 0≤k≤p(n)0(n) is the number of a computation step. Variables Intended interpretation How many?[7] Ti,j,k_i,j,k True if tape cell i contains symbol j at step k of the computation. O(p(n)2)(p(n)^2) Hi,k_i,k True if M's read/write head is at tape cell i at step k of the computation. O(p(n)2)(p(n)^2) Qq,k_q,k True if M is in state q at step k of the computation. O(p(n))(p(n)) Define the Boolean expression B to be the conjunction of the sub-expressions in the following table, for all −p(n)≤i≤p(n)-p(n)(n) and 0≤k≤p(n)0(n): Expression Conditions Interpretation How many? Ti,j,0_i,j,0 Tape cell i initially contains symbol j Initial contents of the tape. For i>n−1>n-1 and i<0<0, outside of the actual input I, the initial symbol is the special default/blank symbol. O(p(n))(p(n)) Qs,0_s,0 Initial state of M. 1 H0,0_0,0 Initial position of read/write head. 1 ¬Ti,j,k∨¬Ti,j′,k_i,j,k_i,j',k j≠j′' At most one symbol per tape cell. O(p(n)2)(p(n)^2) ⋁j∈ΣTi,j,k⋁_j∈ΣT_i,j,k At least one symbol per tape cell. O(p(n)2)(p(n)^2) Ti,j,k∧Ti,j′,k+1→Hi,k_i,j,k_i,j',k+1_i,k j≠j′' Tape remains unchanged unless written by head. O(p(n)2)(p(n)^2) ¬Qq,k∨¬Qq′,k_q,k_q',k q≠q′' At most one state at a time. O(p(n))(p(n)) ⋁q∈QQq,k⋁_qQ_q,k At least one state at a time. O(p(n))(p(n)) ¬Hi,k∨¬Hi′,k_i,k_i',k i≠i′' At most one head position at a time. O(p(n)3)(p(n)^3) ⋁−p(n)≤i≤p(n)Hi,k⋁_-p(n)(n)H_i,k At least one head position at a time. O(p(n)2)(p(n)^2) (Hi,k∧Qq,k∧Ti,σ,k)→⋁((q,σ),(q′,σ′,d))∈δ(Hi+d,k+1∧Qq′,k+1∧Ti,σ′,k+1)[ (H_i,k_q,k_i,σ,k)→; ⋁_((q,σ),(q',σ',d))∈δ(H_i+d,+̨1_q',+̨1_i, sigma',+̨1) ] k<p(n)<p(n) Possible transitions at computation step k when head is at position i. O(p(n)2)(p(n)^2) ⋁0≤k≤p(n)⋁f∈FQf,k⋁_0(n)⋁_fQ_f,k Must finish in an accepting state, not later than in step p(n)(n). 1 If there is an accepting computation for M on input I, then B is satisfiable by assigning Ti,j,k_i,j,k, Hi,k_i,k and Qi,k_i,k their intended interpretations. On the other hand, if B is satisfiable, then there is an accepting computation for M on input I that follows the steps indicated by the assignments to the variables. There are O(p(n)2)(p(n)^2) Boolean variables, each encodable in space O(log⁡p(n))((n)). The number of clauses is O(p(n)3)(p(n)^3)[8] so the size of B is O(log⁡(p(n))p(n)3)(log(p(n))p(n)^3). Thus the transformation is certainly a polynomial-time many-one reduction, as required. Only the first table row (Ti,j,0_i,j,0) actually depends on the input string I. The remaining lines depend only on the input length n and on the machine M; they formalize a generic computation of M for up to p(n)(n) steps. The transformation makes extensive use of the polynomial p(n)(n). As a consequence, the above proof is not constructive: even if M is known, witnessing the membership of the given problem in NP, the transformation cannot be effectively computed, unless an upper bound p(n)(n) of M's time complexity is also known.