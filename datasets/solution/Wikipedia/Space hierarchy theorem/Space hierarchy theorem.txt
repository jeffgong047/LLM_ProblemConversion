Both deterministic and nondeterministic machines can solve more problems given more spaceIn computational complexity theory, the space hierarchy theorems are separation results that show that both deterministic and nondeterministic machines can solve more problems in (asymptotically) more space, subject to certain conditions. For example, a deterministic Turing machine can solve more decision problems in space n log n than in space n. The somewhat weaker analogous theorems for time are the time hierarchy theorems.
The foundation for the hierarchy theorems lies in the intuition that
with either more time or more space comes the ability to compute more
functions (or decide more languages).  The hierarchy theorems are used
to demonstrate that the time and space complexity classes form a
hierarchy where classes with tighter bounds contain fewer languages
than those with more relaxed bounds.  Here we define and prove the
space hierarchy theorem.
The space hierarchy theorems rely on the concept of space-constructible functions. The deterministic and nondeterministic space hierarchy theorems state that for all space-constructible functions f(n),

SPACE(o(f(n)))âŠŠSPACE(f(n))ğ–²ğ–¯ğ– ğ–¢ğ–¤(o(f(n)))âŠŠğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n)),
where SPACE stands for either DSPACE or NSPACE, and o refers to the little o notation.


Statement[edit]
Formally, a function f:NâŸ¶N:â„•âŸ¶â„• is space-constructible if f(n)â‰¥logâ¡n(n)â‰¥logÂ n and there exists a Turing machine
which computes the function f(n)(n) in space O(f(n))(f(n)) when starting
with an input 1n1^n, where 1n1^n represents a string of n consecutive 1s. Most of the common functions that we work with are space-constructible, including polynomials, exponents, and logarithms.
For every space-constructible function f:NâŸ¶N:â„•âŸ¶â„•, there exists a language L that is decidable in space
O(f(n))(f(n)) but not in space o(f(n))(f(n)).

Proof[edit]
The goal is to define a language that can be decided in space O(f(n))(f(n)) but not space o(f(n))(f(n)).  The language is defined as L:


L=(âŸ¨MâŸ©,10k):Musesspaceâ‰¤f(|âŸ¨MâŸ©,10k|)andtimeâ‰¤2f(|âŸ¨MâŸ©,10k|)andMdoesnotaccept(âŸ¨MâŸ©,10k)={Â (âŸ©,10^k):M(|âŸ©,10^k|)â‰¤2^f(|âŸ©,10^k|)M(âŸ©,10^k)Â }


For any machine M that decides a language in space o(f(n))(f(n)), L will differ in at least one spot from the language of M. Namely, for some large enough k, M will use space â‰¤f(|âŸ¨MâŸ©,10k|)(|âŸ©,10^k|) on (âŸ¨MâŸ©,10k)(âŸ©,10^k) and will therefore differ at its value.
On the other hand, L is in SPACE(f(n))ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n)). The algorithm for deciding the language L is as follows:

On an input x, compute f(|x|)(|x|) using space-constructibility, and mark off f(|x|)(|x|) cells of tape. Whenever an attempt is made to use more than f(|x|)(|x|) cells, reject.
If x is not of the form âŸ¨MâŸ©,10kâŸ©,10^k for some TM M, reject.
Simulate M on input x for at most 2f(|x|)2^f(|x|) steps (using f(|x|)(|x|) space).  If the simulation tries to use more than f(|x|)(|x|) space or more than 2f(|x|)2^f(|x|) operations, then reject.
If M accepted x during this simulation, then reject; otherwise, accept.
Note on step 3: Execution is limited to 2f(|x|)2^f(|x|) steps in order to avoid the case where M does not halt on the input x.  That is, the case where M consumes space of only O(f(x))(f(x)) as required, but runs for infinite time.
The above proof holds for the case of PSPACE, but some changes need to be made for the case of NPSPACE. The crucial point is that while on a deterministic TM, acceptance and rejection can be inverted (crucial for step 4), this is not possible on a non-deterministic machine.
For the case of NPSPACE, L needs to be redefined first:


L=(âŸ¨MâŸ©,10k):Musesspaceâ‰¤f(|âŸ¨MâŸ©,10k|)andMaccepts(âŸ¨MâŸ©,10k)={Â (âŸ©,10^k):M(|âŸ©,10^k|)M(âŸ©,10^k)Â }


Now, the algorithm needs to be changed to accept L by modifying step 4 to:

If M accepted x during this simulation, then accept; otherwise, reject.
L can not be decided by a TM using o(f(n))(f(n)) cells. Assuming L can be decided by some TM M using o(f(n))(f(n)) cells, and following from the Immermanâ€“SzelepcsÃ©nyi theorem, LÂ¯L can also be determined by a TM (called MÂ¯M) using o(f(n))(f(n)) cells. Here lies the contradiction, therefore the assumption must be false:

If w=(âŸ¨MÂ¯âŸ©,10k)=(âŸ¨MâŸ©,10^k) (for some large enough k) is not in LÂ¯L then M will accept it, therefore MÂ¯M rejects w, therefore w is in LÂ¯L (contradiction).
If w=(âŸ¨MÂ¯âŸ©,10k)=(âŸ¨MâŸ©,10^k) (for some large enough k) is in LÂ¯L then M will reject it, therefore MÂ¯M accepts w, therefore w is not in LÂ¯L (contradiction).
Comparison and improvements[edit]
The space hierarchy theorem is stronger than the analogous time hierarchy theorems in several ways:

It only requires s(n) to be at least log n instead of at least n.
It can separate classes with any asymptotic difference, whereas the time hierarchy theorem requires them to be separated by a logarithmic factor.
It only requires the function to be space-constructible, not time-constructible.
It seems to be easier to separate classes in space than in time. Indeed, whereas the time hierarchy theorem has seen little remarkable improvement since its inception, the nondeterministic space hierarchy theorem has seen at least one important improvement by Viliam Geffert in his 2003 paper "Space hierarchy theorem revised". This paper made several generalizations of the theorem:

It relaxes the space-constructibility requirement. Instead of merely separating the union classes DSPACE(O(s(n))ğ–£ğ–²ğ–¯ğ– ğ–¢ğ–¤(O(s(n)) and DSPACE(o(s(n))ğ–£ğ–²ğ–¯ğ– ğ–¢ğ–¤(o(s(n)), it separates DSPACE(f(n))ğ–£ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n)) from DSPACE(g(n))ğ–£ğ–²ğ–¯ğ– ğ–¢ğ–¤(g(n)) where f(n)(n) is an arbitrary O(s(n))(s(n)) function and g(n) is a computable o(s(n))(s(n)) function. These functions need not be space-constructible or even monotone increasing.
It identifies a unary language, or tally language, which is in one class but not the other. In the original theorem, the separating language was arbitrary.
It does not require s(n)(n) to be at least log n; it can be any nondeterministically fully space-constructible function.
Refinement of space hierarchy[edit]
If space is measured as the number of cells used regardless of alphabet size, then SPACE(f(n))=SPACE(O(f(n)))ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n))=ğ–²ğ–¯ğ– ğ–¢ğ–¤(O(f(n))) because one can achieve any linear compression by switching to a larger alphabet.  However, by measuring space in bits, a much sharper separation is achievable for deterministic space.  Instead of being defined up to a multiplicative constant, space is now defined up to an additive constant.  However, because any constant amount of external space can be saved by storing the contents into the internal state, we still have SPACE(f(n))=SPACE(f(n)+O(1))ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n))=ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n)+O(1)).
Assume that f is space-constructible.  SPACE is deterministic.

For a wide variety of sequential computational models, including for Turing machines, SPACE(f(n)-Ï‰(log(f(n)+n))) âŠŠ SPACE(f(n)).  This holds even if SPACE(f(n)-Ï‰(log(f(n)+n))) is defined using a different computational model than SPACE(f(n))ğ–²ğ–¯ğ– ğ–¢ğ–¤(f(n)) because the different models can simulate each other with O(logâ¡(f(n)+n))(log(f(n)+n)) space overhead.
For certain computational models, we even have SPACE(f(n)-Ï‰(1)) âŠŠ SPACE(f(n)).  In particular, this holds for Turing machines if we fix the alphabet, the number of heads on the input tape, the number of heads on the worktape (using a single worktape), and add delimiters for the visited portion of the worktape (that can be checked without increasing space usage).  SPACE(f(n)) does not depend on whether the worktape is infinite or semi-infinite.  We can also have a fixed number of worktapes if f(n) is either a SPACE constructible tuple giving the per-tape space usage, or a SPACE(f(n)-Ï‰(log(f(n)))-constructible number giving the total space usage (not counting the overhead for storing the length of each tape).
The proof is similar to the proof of the space hierarchy theorem, but with two complications: The universal Turing machine has to be space-efficient, and the reversal has to be space-efficient. One can generally construct universal Turing machines with O(logâ¡(space))(log(space)) space overhead, and under appropriate assumptions, just O(1)(1) space overhead (which may depend on the machine being simulated). For the reversal, the key issue is how to detect if the simulated machine rejects by entering an infinite (space-constrained) loop.  Simply counting the number of steps taken would increase space consumption by about f(n)(n).  At the cost of a potentially exponential time increase, loops can be detected space-efficiently as follows:[1]
Modify the machine to erase everything and go to a specific configuration A on success. Use depth-first search to determine whether A is reachable in the space bound from the starting configuration. The search starts at A and goes over configurations that lead to A. Because of determinism, this can be done in place and without going into a loop.
It can also be determined whether the machine exceeds a space bound (as opposed to looping within the space bound) by iterating over all configurations about to exceed the space bound and checking (again using depth-first search) whether the initial configuration leads to any of them.

Corollaries[edit]
Corollary 1[edit]
For any two functions f1_1, f2:NâŸ¶N_2:â„•âŸ¶â„•, where f1(n)_1(n) is o(f2(n))(f_2(n)) and f2_2 is space-constructible, SPACE(f1(n))âŠŠSPACE(f2(n))ğ–²ğ–¯ğ– ğ–¢ğ–¤(f_1(n))âŠŠğ–²ğ–¯ğ– ğ–¢ğ–¤(f_2(n)).
This corollary lets us separate various space complexity classes.
For any function nk^k is space-constructible for any natural
number k. Therefore for any two natural numbers k1<k2_1<k_2 we can
prove SPACE(nk1)âŠŠSPACE(nk2)ğ–²ğ–¯ğ– ğ–¢ğ–¤(n^k_1)âŠŠğ–²ğ–¯ğ– ğ–¢ğ–¤(n^k_2). This idea can be extended for real numbers in the following corollary. This demonstrates the detailed hierarchy within the PSPACE class.

Corollary 2[edit]
For any two nonnegative real numbers a1<a2,SPACE(na1)âŠŠSPACE(na2)_1<a_2,ğ–²ğ–¯ğ– ğ–¢ğ–¤(n^a_1)âŠŠğ–²ğ–¯ğ– ğ–¢ğ–¤(n^a_2).

Corollary 3[edit]
NL âŠŠ PSPACE.
Proof[edit]
Savitch's theorem shows that NLâŠ†SPACE(log2â¡n)ğ–­ğ–«âŠ†ğ–²ğ–¯ğ– ğ–¢ğ–¤(log^2n), while the space hierarchy theorem shows that SPACE(log2â¡n)âŠŠSPACE(n)ğ–²ğ–¯ğ– ğ–¢ğ–¤(log^2n)âŠŠğ–²ğ–¯ğ– ğ–¢ğ–¤(n). The result is this corollary along with the fact that TQBF âˆ‰ NL
since TQBF is PSPACE-complete.
This could also be proven using the non-deterministic space hierarchy theorem to show that NL âŠŠ NPSPACE, and using Savitch's theorem to show that PSPACE = NPSPACE.

Corollary 4[edit]
PSPACE âŠŠ EXPSPACE.
This last corollary shows the existence of decidable problems that are intractable. In other words, their decision procedures must use more than polynomial space.

Corollary 5[edit]
There are problems in PSPACE requiring an arbitrarily large exponent to solve; therefore PSPACE does not collapse to DSPACE(nk) for some constant k.

Corollary 6[edit]
SPACE(n) â‰  PTIME.
To see it, assume the contrary, thus any problem decided in space O(n)(n) is decided in time O(nc)(n^c), and any problem L decided in space  O(nb)(n^b) is decided in time O((nb)c)=O(nbc)((n^b)^c)=O(n^bc). Now P:=â‹ƒkâˆˆNDTIME(nk)ğ–¯:=â‹ƒ_kâˆˆâ„•ğ–£ğ–³ğ–¨ğ–¬ğ–¤(n^k), thus P is closed under such a change of bound, that is â‹ƒkâˆˆNDTIME(nbk)âŠ†Pâ‹ƒ_kâˆˆâ„•ğ–£ğ–³ğ–¨ğ–¬ğ–¤(n^bk)âŠ†ğ–¯, so LâˆˆPâˆˆğ–¯. This implies that for all b,SPACE(nb)âŠ†PâŠ†SPACE(n),ğ–²ğ–¯ğ– ğ–¢ğ–¤(n^b)âŠ†ğ–¯âŠ†ğ–²ğ–¯ğ– ğ–¢ğ–¤(n), but the space hierarchy theorem implies that SPACE(n2)âŠˆSPACE(n)ğ–²ğ–¯ğ– ğ–¢ğ–¤(n^2)âŠˆğ–²ğ–¯ğ– ğ–¢ğ–¤(n), and Corollary 6 follows. Note that this argument neither proves that PâŠˆSPACE(n)ğ–¯âŠˆğ–²ğ–¯ğ– ğ–¢ğ–¤(n) nor that SPACE(n)âŠˆPğ–²ğ–¯ğ– ğ–¢ğ–¤(n)âŠˆğ–¯, as to reach a contradiction we used the negation of both sentences, that is we used both inclusions, and can only deduce that at least one fails. It is currently unknown which fail(s) but conjectured that both do, that is that SPACE(n)ğ–²ğ–¯ğ– ğ–¢ğ–¤(n) and Pğ–¯ are incomparable -at least for deterministic space.[2] This question is related to that of the time complexity of (nondeterministic) linear bounded automata which accept the complexity class NSPACE(n)ğ–­ğ–²ğ–¯ğ– ğ–¢ğ–¤(n) (aka as context-sensitive languages, CSL); so by the above CSL is not known to be decidable in polynomial time -see also Kuroda's two problems on LBA.

See also[edit]
Time hierarchy theorem
References[edit]


^ Sipser, Michael (1978). "Halting Space-Bounded Computations". Proceedings of the 19th Annual Symposium on Foundations of Computer Science.

^ "How do we know that PÂ != LINSPACE without knowing if one is a subset of the other?".


Arora, Sanjeev; Barak, Boaz (2009). Computational complexity. A modern approach. Cambridge University Press. ISBNÂ 978-0-521-42426-4. ZblÂ 1193.68112.
Luca Trevisan. Notes on Hierarchy Theorems. Handout 7. CS172: Automata, Computability and Complexity. U.C. Berkeley. April 26, 2004.
Viliam Geffert. Space hierarchy theorem revised. Theoretical Computer Science, volume 295, number 1â€“3, p.Â 171-187. February 24, 2003.
Sipser, Michael (1997). Introduction to the Theory of Computation. PWS Publishing. ISBNÂ 0-534-94728-X. Pages 306â€“310 of section 9.1: Hierarchy theorems.
Papadimitriou, Christos (1993). Computational Complexity (1stÂ ed.). Addison Wesley. ISBNÂ 0-201-53082-1. Section 7.2: The Hierarchy Theorem, pp.Â 143â€“146.



