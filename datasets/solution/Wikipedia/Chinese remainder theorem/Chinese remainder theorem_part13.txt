sieving: The smallest two solutions, 23 and 128, of the original formulation of the Chinese remainder theorem problem found using a sieve The search of the solution may be made dramatically faster by sieving. For this method, we suppose, without loss of generality, that 0≤ai<ni0_i<n_i (if it were not the case, it would suffice to replace each ai_i by the remainder of its division by ni_i). This implies that the solution belongs to the arithmetic progression a1,a1+n1,a1+2n1,…_1,a_1+n_1,a_1+2n_1,… By testing the values of these numbers modulo n2,_2, one eventually finds a solution x2_2 of the two first congruences. Then the solution belongs to the arithmetic progression x2,x2+n1n2,x2+2n1n2,…_2,x_2+n_1n_2,x_2+2n_1n_2,… Testing the values of these numbers modulo n3,_3, and continuing until every modulus has been tested eventually yields the solution. This method is faster if the moduli have been ordered by decreasing value, that is if n1>n2>⋯>nk._1>n_2>⋯>n_k. For the example, this gives the following computation. We consider first the numbers that are congruent to 4 modulo 5 (the largest modulus), which are 4, 9 = 4 + 5, 14 = 9 + 5, ... For each of them, compute the remainder by 4 (the second largest modulus) until getting a number congruent to 3 modulo 4. Then one can proceed by adding 20 = 5 × 4 at each step, and computing only the remainders by 3. This gives 4 mod 4 → 0. Continue 4 + 5 = 9 mod 4 →1. Continue 9 + 5 = 14 mod 4 → 2. Continue 14 + 5 = 19 mod 4 → 3. OK, continue by considering remainders modulo 3 and adding 5 × 4 = 20 each time 19 mod 3 → 1. Continue 19 + 20 = 39 mod 3 → 0. OK, this is the result. This method works well for hand-written computation with a product of moduli that is not too big. However, it is much slower than other methods, for very large products of moduli. Although dramatically faster than the systematic search, this method also has an exponential time complexity and is therefore not used on computers. Using the existence