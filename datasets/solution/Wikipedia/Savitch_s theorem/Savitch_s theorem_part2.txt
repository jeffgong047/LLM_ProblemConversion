Proof: The proof relies on an algorithm for STCON, the problem of determining whether there is a path between two vertices in a directed graph, which runs in O((log⁡n)2)(()^2) space for n vertices. The basic idea of the algorithm is to solve recursively a somewhat more general problem, testing the existence of a path from a vertex s to another vertex t that uses at most k edges, for a parameter k given as input. STCON is a special case of this problem where k is set large enough to impose no restriction on the paths (for instance, equal to the total number of vertices in the graph, or any larger value). To test for a k-edge path from s to t, a deterministic algorithm can iterate through all vertices u, and recursively search for paths of half the length from s to u and from u to t. This algorithm can be expressed in pseudocode (in Python syntax) as follows: def stcon(s, t) -> bool: """Test whether a path of any length exists from s to t""" return k_edge_path(s, t, n) # n is the number of vertices def k_edge_path(s, t, k) -> bool: """Test whether a path of length at most k exists from s to t""" if k == 0: return s == t if k == 1: return (s, t) in edges for u in vertices: if k_edge_path(s, u, floor(k / 2)) and k_edge_path(u, t, ceil(k / 2)): return True return False Because each recursive call halves the parameter k, the number of levels of recursion is ⌈log2⁡n⌉⌈log_2n⌉. Each level requires O(log⁡n)() bits of storage for its function arguments and local variables: k and the vertices s, t, and u require ⌈log2⁡n⌉⌈log_2n⌉ bits each. The total auxiliary space complexity is thus O((log⁡n)2)(()^2). The input graph is considered to be represented in a separate read-only memory and does not contribute to this auxiliary space bound. Alternatively, it may be represented as an implicit graph. Although described above in the form of a program in a high-level language, the same algorithm may be implemented with the same asymptotic space bound on a Turing machine. This algorithm can be applied to an implicit graph whose vertices represent the configurations of a nondeterministic Turing machine and its tape, running within a given space bound f(n)(n). The edges of this graph represent the nondeterministic transitions of the machine, s is set to the initial configuration of the machine, and t is set to a special vertex representing all accepting halting states. In this case, the algorithm returns true when the machine has a nondeterministic accepting path, and false otherwise. The number of configurations in this graph is O(2f(n))(2^f(n)), from which it follows that applying the algorithm to this implicit graph uses space O(f(n)2)(f(n)^2). Thus by deciding connectivity in a graph representing nondeterministic Turing machine configurations, one can decide membership in the language recognized by that machine, in space proportional to the square of the space used by the Turing machine.