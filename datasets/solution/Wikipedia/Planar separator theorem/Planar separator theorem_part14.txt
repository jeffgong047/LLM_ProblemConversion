algorithms: Separator decompositions can be of use in designing efficient divide and conquer algorithms for solving problems on planar graphs. As an example, one problem that can be solved in this way is to find the shortest cycle in a weighted planar digraph. This may be solved by the following steps: Partition the given graph G into three subsets S, A, B according to the planar separator theorem Recursively search for the shortest cycles in A and B Use Dijkstra's algorithm to find, for each vertex s in S, the shortest cycle through s in G. Return the shortest of the cycles found by the above steps. The time for the two recursive calls to A and B in this algorithm is dominated by the time to perform the O(n)(√(n)) calls to Dijkstra's algorithm, so this algorithm finds the shortest cycle in O(n3/2log⁡n)(n^3/2) time. A faster algorithm for the same shortest cycle problem, running in time O(nlog3⁡n)(nlog^3n), was given by Wulff-Nilsen (2009). His algorithm uses the same separator-based divide and conquer structure, but uses simple cycle separators rather than arbitrary separators, so that the vertices of S belong to a single face of the graphs inside and outside the cycle separator. He then replaces the O(n)(√(n)) separate calls to Dijkstra's algorithm with more sophisticated algorithms to find shortest paths from all vertices on a single face of a planar graph and to combine the distances from the two subgraphs. For weighted but undirected planar graphs, the shortest cycle is equivalent to the minimum cut in the dual graph and can be found in O(nlog⁡log⁡n)(nlog) time,[27] and the shortest cycle in an unweighted undirected planar graph (its girth) may be found in time O(n)(n).[28] (However, the faster algorithm for unweighted graphs is not based on the separator theorem.) Frederickson proposed another faster algorithm for single source shortest paths by implementing separator theorem in planar graphs.[29] This is an improvement of Dijkstra's algorithm with iterative search on a carefully selected subset of the vertices. This version takes O(nlog⁡n)(n√()) time in an n-vertex graph. Separators are used to find a division of a graph, that is, a partition of the edge-set into two or more subsets, called regions. A node is said to be contained in a region if some edge of the region is incident to the node. A node contained in more than one region is called a boundary node of the regions containing it. The method uses the notion of a r-division of an n-node graph that is a graph division into O(n/r)(n/r) regions, each containing O(r)(r) nodes including O(r)(√(r)) boundary nodes. Frederickson showed that an r-division can be found in O(nlog⁡n)(n) time by recursive application of separator theorem. The sketch of his algorithm to solve the problem is as follows. Preprocessing Phase: Partition the graph into carefully selected subsets of vertices and determine the shortest paths between all pairs of vertices in these subsets, where intermediate vertices on this path are not in the subset. This phase requires a planar graph G0_0 to be transformed into G with no vertex having degree greater than three. From a corollary of Euler's formula, the number of vertices in the resulting graph will be n≤6n0−12≤6n_0-12, where n0_0 is the number of vertices in G0_0. This phase also ensures the following properties of a suitable r-division. A suitable r-division of a planar graph is an r-division such that, each boundary vertex is contained in at most three regions, and any region that is not connected consists of connected components, all of which share boundary vertices with exactly the same set of either one or two connected regions. Search Phase: Main Thrust: Find shortest distances from the source to each vertex in the subset. When a vertex v in the subset is closed, the tentative distance d(w)(w) must be updated for all vertices w in the subset such that a path exists from v to w. Mop-up: Determine shortest distances to every remaining vertex. Henzinger et al. extended Frederickson's r-division technique for the single source shortest path algorithm in planar graphs for nonnegative edge-lengths and proposed a linear time algorithm.[30] Their method generalizes Frederickson's notion of graph-divisions such that now an (r,s)(r,s)-division of an n-node graph is a division into O(n/r)(n/r) regions, each containing rO(1)^O(1) nodes, each having at most s boundary nodes. If an (r,s)(r,s)-division is repeatedly divided into smaller regions, that is called a recursive division. This algorithm uses approximately log∗⁡nlog^*n levels of divisions, where log∗log^* denotes the iterated logarithm function. The recursive division is represented by a rooted tree whose leaves are labeled by distinct edge of G. The root of the tree represents the region consisting of all of G, the children of the root represent the subregions into which that region is divided and so on. Each leaf (atomic region) represents a region containing exactly one edge. Nested dissection is a separator based divide and conquer variation of Gaussian elimination for solving sparse symmetric systems of linear equations with a planar graph structure, such as the ones arising from the finite element method. It involves finding a separator for the graph describing the system of equations, recursively eliminating the variables in the two subproblems separated from each other by the separator, and then eliminating the variables in the separator.[31] The fill-in of this method (the number of nonzero coefficients of the resulting Cholesky decomposition of the matrix) is O(nlog⁡n)(n),[32] allowing this method to be competitive with iterative methods for the same problems.[31] Klein, Mozes and Weimann[33] gave an O(nlog2⁡n)(nlog^2n)-time, linear-space algorithm to find the shortest path distances from a source vertex s to all other vertices for a directed planar graph with positive and negative arc-lengths containing no negative cycles. Their algorithm uses planar graph separators to find a Jordan curve C that passes through O(n)(√(n)) nodes (and no arcs) such that between n/3/3 and 2n/32n/3 nodes are enclosed by C. Nodes through which C passes are boundary nodes. The original graph G is separated into two subgraphs G0_0 and G1_1 by cutting the planar embedding along C and duplicating the boundary nodes. The boundary nodes in each graph Gi_i lie on the boundary of a single face Fi_i. The overview of their approach is given below. Recursive call: The first stage recursively computes the distances from r within each graph Gi_i. Intra-part boundary-distances: For each graph Gi_i compute all distances in Gi_i between boundary nodes. This takes O(nlog⁡n)(n) time. Single-source inter-part boundary distances: A shortest path in G passes back and forth between G0_0 and G1_1 to compute the distances in G from r to all the boundary nodes. Alternating iterations use the all-boundary-distances in G0_0 and G1_1. The number of iterations is O(n)(√(n)), and the overall time for this stage is O(nα(n))(nα(n)) where α(n)α(n) is the inverse Ackermann function. Single-source inter-part distances: The distances computed in the previous stages are used, together with a Dijkstra computation within a modified version of each Gi , to compute the distances in G from r to all the nodes. This stage takes O(nlog⁡n)(n) time. Rerooting single-source distances: The distances from r in G are transformed into nonnegative lengths, and again Dijkstra's algorithm is used to compute distances from s. This stage requires O(nlog⁡n)(n) time. An important part of this algorithm is the use of price functions and reduced lengths. For a directed graph G with arc-lengths ℓ(uv)ℓ(uv), a price function is a function φφ from the nodes of G to the real numbers. For an arc uv, the reduced length with respect to φφ is ℓφ(uv)=ℓ(uv)+φ(u)−φ(v)ℓ_φ(uv)=ℓ(uv)+φ(u)-φ(v). A feasible price function is a price function that induces nonnegative reduced lengths on all arcs of G. It is useful in transforming a shortest-path problem involving positive and negative lengths into one involving only nonnegative lengths, which can then be solved using Dijkstra's algorithm. The separator based divide and conquer paradigm has also been used to design data structures for dynamic graph algorithms[34] and point location,[35] algorithms for polygon triangulation,[20] shortest paths,[36] and the construction of nearest neighbor graphs,[37] and approximation algorithms for the maximum independent set of a planar graph.[35] Exact solution of NP-hard optimization