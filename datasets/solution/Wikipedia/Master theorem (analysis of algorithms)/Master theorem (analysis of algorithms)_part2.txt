Introduction: Consider a problem that can be solved using a recursive algorithm such as the following: procedure p(input x of size n): if n < some constant k: Solve x directly without recursion else: Create a subproblems of x, each having size n/b Call procedure p recursively on each subproblem Combine the results from the subproblems Solution tree. The above algorithm divides the problem into a number of subproblems recursively, each subproblem being of size n/b. Its solution tree has a node for each recursive call, with the children of that node being the other calls made from that call. The leaves of the tree are the base cases of the recursion, the subproblems (of size less than k) that do not recurse. The above example would have a child nodes at each non-leaf node. Each node does an amount of work that corresponds to the size of the subproblem n passed to that instance of the recursive call and given by f(n)(n). The total amount of work done by the entire algorithm is the sum of the work performed by all the nodes in the tree. The runtime of an algorithm such as the p above on an input of size n, usually denoted T(n)(n), can be expressed by the recurrence relation T(n)=aT(nb)+f(n),(n)=a T(n/b)+f(n), where f(n)(n) is the time to create the subproblems and combine their results in the above procedure. This equation can be successively substituted into itself and expanded to obtain an expression for the total amount of work done.[2] The master theorem allows many recurrence relations of this form to be converted to Î˜-notation directly, without doing an expansion of the recursive relation. Generic