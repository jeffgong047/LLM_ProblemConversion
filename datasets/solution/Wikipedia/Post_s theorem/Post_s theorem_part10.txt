jumps: More generally, suppose every set that is recursively enumerable by an oracle machine with an oracle for ∅(p)∅^(p) is in Σp+10Σ_p+1^0. Then for an oracle machine with an oracle for ∅(p+1)∅^(p+1), ψO(m)=∃m1:ψH(m,m1)ψ^O(m)=_1:ψ_H(m,m_1) is in Σp+10Σ_p+1^0. Since ψO(m)ψ^O(m) is the same as φ(n)φ(n) for the previous Turing jump, it can be constructed (as we have just done with φ(n)φ(n) above) so that ψH(m,m1)ψ_H(m,m_1) in Πp0Π_p^0. After moving to prenex formal form the new φ(n)φ(n) is in Σp+20Σ_p+2^0. By induction, every set that is recursively enumerable by an oracle machine with an oracle for ∅(p)∅^(p), is in Σp+10Σ_p+1^0. The other direction can be proven by induction as well: Suppose every formula in Σp+10Σ_p+1^0 can be enumerated by an oracle machine with an oracle for ∅(p)∅^(p). Now Suppose φ(n)φ(n) is a formula in Σp+20Σ_p+2^0 with k1_1 existential quantifiers followed by k2_2 universal quantifiers etc. Equivalently, φ(n)φ(n) has k1_1> existential quantifiers followed by a negation of a formula in Σp+10Σ_p+1^0; the latter formula can be enumerated by an oracle machine with an oracle for ∅(p)∅^(p) and can thus be checked immediately by an oracle for ∅(p+1)∅^(p+1). We may thus enumerate the k1_1–tuples of natural numbers and run an oracle machine with an oracle for ∅(p+1)∅^(p+1) that goes through all of them until it finds a satisfaction for the formula. This oracle machine halts on precisely the set of natural numbers satisfying φ(n)φ(n), and thus enumerates its corresponding set.