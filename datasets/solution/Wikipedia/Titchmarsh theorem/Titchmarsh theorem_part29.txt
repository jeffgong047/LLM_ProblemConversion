transform: Figure 1: Filter whose frequency response is bandlimited to about 95% of the Nyquist frequency Figure 2: Hilbert transform filter with a highpass frequency response Figure 3. Figure 4. The Hilbert transform of cos(ωt) is sin(ωt). This figure shows sin(ωt) and two approximate Hilbert transforms computed by the MATLAB library function, hilbert() Figure 5. Discrete Hilbert transforms of a cosine function, using piecewise convolution For a discrete function, u[n][n], with discrete-time Fourier transform (DTFT), U(ω)(ω), and discrete Hilbert transform u^[n]û[n], the DTFT of u^[n]û[n] in the region −π < ω < π is given by: DTFT⁡(u^)=U(ω)⋅(−i⋅sgn⁡(ω)).DTFT(û)=U(ω)·(-i·sgn(ω)). The inverse DTFT, using the convolution theorem, is:[46] u^[n]=DTFT−1(U(ω))∗DTFT−1(−i⋅sgn⁡(ω))=u[n]∗12π∫−ππ(−i⋅sgn⁡(ω))⋅eiωndω=u[n]∗12π[∫−π0i⋅eiωndω−∫0πi⋅eiωndω]⏟h[n],û[n] =DTFT^-1(U(ω)){DTFT^-1(-i·sgn(ω)) =u[n]{1/2π∫_-π^π(-i·sgn(ω))^i dω =u[n] underbrace1/2π[∫_-π^0i^i dω-∫_0^πi^i dω]_h[n], where h[n]≜0,forneven2πnfornodd,[n] triangleq{0, forneven 2/ fornodd, which is an infinite impulse response (IIR). When the convolution is performed numerically, an FIR approximation is substituted for h[n], as shown in Figure 1. An FIR filter with an odd number of anti-symmetric coefficients is called Type III, which inherently exhibits responses of zero magnitude at frequencies 0 and Nyquist, resulting in this case in a bandpass filter shape. A Type IV design (even number of anti-symmetric coefficients) is shown in Figure 2. Since the magnitude response at the Nyquist frequency does not drop out, it approximates an ideal Hilbert transformer a little better than the odd-tap filter. However A typical (i.e. properly filtered and sampled) u[n] sequence has no useful components at the Nyquist frequency. The Type IV impulse response requires a 1⁄2 sample shift in the h[n] sequence. That causes the zero-valued coefficients to become non-zero, as seen in Figure 2. So a Type III design is potentially twice as efficient as Type IV. The group delay of a Type III design is an integer number of samples, which facilitates aligning u^[n]û[n] with u[n],[n], to create an analytic signal. The group delay of Type IV is halfway between two samples. The MATLAB function, hilbert(u,N),[47] convolves a u[n] sequence with the periodic summation:[A] hN[n]≜∑m=−∞∞h[n−mN]_N[n] triangleq∑_m=-∞^∞h[n-mN] [B][C] and returns one cycle (N samples) of the periodic result in the imaginary part of a complex-valued output sequence. The convolution is implemented in the frequency domain as the product of the array DFT(u[n])DFT(u[n]) with samples of the −i sgn(ω) distribution (whose real and imaginary components are all just 0 or ±1). Figure 3 compares a half-cycle of hN[n] with an equivalent length portion of h[n]. Given an FIR approximation for h[n],[n], denoted by h [n],h̃[n], substituting DFT(h [n])DFT(h̃[n]) for the −i sgn(ω) samples results in an FIR version of the convolution. The real part of the output sequence is the original input sequence, so that the complex output is an analytic representation of u[n]. When the input is a segment of a pure cosine, the resulting convolution for two different values of N is depicted in Figure 4 (red and blue plots). Edge effects prevent the result from being a pure sine function (green plot). Since hN[n] is not an FIR sequence, the theoretical extent of the effects is the entire output sequence. But the differences from a sine function diminish with distance from the edges. Parameter N is the output sequence length. If it exceeds the length of the input sequence, the input is modified by appending zero-valued elements. In most cases, that reduces the magnitude of the differences. But their duration is dominated by the inherent rise and fall times of the h[n] impulse response. An appreciation for the edge effects is important when a method called overlap-save is used to perform the convolution on a long u[n] sequence. Segments of length N are convolved with the periodic function: h N[n]≜∑m=−∞∞h [n−mN].h̃_N[n] triangleq∑_m=-∞^∞h̃[n-mN]. When the duration of non-zero values of h [n]h̃[n] is M<N,<N, the output sequence includes N − M + 1 samples of u^.û. M − 1 outputs are discarded from each block of N, and the input blocks are overlapped by that amount to prevent gaps. Figure 5 is an example of using both the IIR hilbert(·) function and the FIR approximation. In the example, a sine function is created by computing the Discrete Hilbert transform of a cosine function, which was processed in four overlapping segments, and pieced back together. As the FIR result (blue) shows, the distortions apparent in the IIR result (red) are not caused by the difference between h[n] and hN[n] (green and red in Figure 3). The fact that hN[n] is tapered (windowed) is actually helpful in this context. The real problem is that it's not windowed enough. Effectively, M = N, whereas the overlap-save method needs M < N. Number-theoretic Hilbert